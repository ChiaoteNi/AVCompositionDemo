//
//  DissolvedMetalRenderer.swift
//  VideoCompositionDemo
//
//  Created by Chiaote Ni on 2022/11/28.
//

import Foundation
import MetalKit

// Metalâ€™s textures originate in the top-left corner.
// The coordinates within the texture are normalized and always within the range of 0->1
// More information you can see the in chapter 1.6 - Metal Coordinate Systems in the following document:
// https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf
// Especially the Figure 1 and Figure 3

fileprivate class PixelBuffers {
    let outputBuffer: CVPixelBuffer
    let foregroundBuffer: CVPixelBuffer
    let backgroundBuffer: CVPixelBuffer

    init(outputBuffer: CVPixelBuffer, foregroundBuffer: CVPixelBuffer, backgroundBuffer: CVPixelBuffer) {
        self.outputBuffer = outputBuffer
        self.foregroundBuffer = foregroundBuffer
        self.backgroundBuffer = backgroundBuffer
    }
}

final class DissolvedMetalRenderer: MetalRendering {

    /// A `MTLDevice` object instance representing a GPU that can execute commands.
    let device: MTLDevice

    /// A `MTLCommandQueue` object used to queue the command buffers for the Metal device to execute.
    let commandQueue: MTLCommandQueue

    /// The default library contains all of the shader functions that were compiled into our app bundle.
    let library: MTLLibrary

    /// Vertex coordinates used for drawing our geometric primitives (triangles).
    /// It's a four-dimensional homogenous vector (x, y, z, w), which the x, y is from (-1, -1) to (1, 1)
    private let vertexes: [Float] = [
        -1.0, 1.0, 0, 1,
        -1.0, -1.0, 0, 1,
        1.0, -1.0, 0, 1,
        -1.0, 1.0, 0, 1,
        1.0, -1.0, 0, 1,
        1.0, 1.0, 0, 1
    ]

    /// Texture coordinates used for drawing textures in the texture coordinate system.
    /// It's a 2-dimensional homogenous vector (x,y), which the x, y is from (0, 0) to (1, 1)
    private let textureCoords: [Float] = [
        0.0, 0.0,
        0.0, 1.0,
        1.0, 1.0,
        0.0, 0.0,
        1.0, 1.0,
        1.0, 0.0
    ]

    private var currentPixelBuffers: PixelBuffers?

    init?() {
        // Ask for the default Metal device; this represents our GPU.
        guard let device = MTLCreateSystemDefaultDevice() else {
            print("Metal is not supported on this device.")
            return nil
        }
        guard let commandQueue = device.makeCommandQueue() else {
            print("commandQueue create failed.")
            return nil
        }
        guard let library = device.makeDefaultLibrary() else {
            print("library not exist.")
            return nil
        }
        self.device = device
        // Create the command queue to submit work to the GPU.
        self.commandQueue = commandQueue
        self.library = library
    }

    func renderPixelBuffer(
        _ outputBuffer: CVPixelBuffer,
        foregroundSource foregroundPixelBuffer: CVPixelBuffer,
        backgroundSource backgroundPixelBuffer: CVPixelBuffer,
        forTweenFactor tween: Float
    ) {

        guard
            let outputTexture = makeTexture(with: outputBuffer),
            let foregroundTexture = makeTexture(with: foregroundPixelBuffer),
            let backgroundTexture = makeTexture(with: backgroundPixelBuffer)
        else {
            return
        }
        // Hold the texture until finish rendering.
        // This is because metal won't increase the retain count for the textures while rendering, so we need to do this by ourselves
        currentPixelBuffers = PixelBuffers(
            outputBuffer: outputBuffer,
            foregroundBuffer: foregroundPixelBuffer,
            backgroundBuffer: backgroundPixelBuffer
        )

        // set up the collection of attachments used as the rendering destination for pixels generated by a rendering pass.
        // in this case, we only need one rendering destination at the same time
        let renderPassDescriptor = MTLRenderPassDescriptor()
        renderPassDescriptor.colorAttachments[0].texture = outputTexture
//        renderPassDescriptor.colorAttachments[0].loadAction = .load

        guard
            let commandBuffer = commandQueue.makeCommandBuffer(),
            let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor),
            let vertexFunction = library.makeFunction(name: "dissolved_vertex_point_func"),
            let fragmentFunction = library.makeFunction(name: "dissolved_fragment_point_func")
        else {
            return
        }

        // Set up the rendering configuration state to use during a rendering pass
        let pipelineDescriptor = MTLRenderPipelineDescriptor()
        pipelineDescriptor.vertexFunction = vertexFunction
        pipelineDescriptor.fragmentFunction = fragmentFunction
        pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm

        do {
            let pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)
            renderTexture(
                foregroundTexture: foregroundTexture,
                backgroundTexture: backgroundTexture,
                with: renderEncoder,
                vertexes: vertexes,
                textureCoords: textureCoords,
                pipelineState: pipelineState,
                tweenFactor: tween
            )
        } catch {
            debugPrint("ðŸ’¥", error)
        }
        renderEncoder.endEncoding()
        commandBuffer.commit()
    }
}

extension DissolvedMetalRenderer {

    private func makeTexture(with pixelBuffer: CVPixelBuffer) -> MTLTexture? {
        let textureWidth = CVPixelBufferGetWidth(pixelBuffer)
        let textureHeight = CVPixelBufferGetHeight(pixelBuffer)

        let descriptor = MTLTextureDescriptor.texture2DDescriptor(
            pixelFormat: .bgra8Unorm,
            width: textureWidth,
            height: textureHeight,
            mipmapped: false
        )
        // Set up this because Metal can optimize operations for a given texture, based on its intended use.
        descriptor.usage = [
            .renderTarget,  // Declare this if we need set up texture to the colorAttachment[0]
            .shaderRead     // Declare this if we need to use texture in the shader function.
        ]

        guard
            // IOSurface is a high-level abstraction around shared memory:
            // â€¢ Very efficient cross-process and cross-API data sharing
            // â€¢ Integrated directly into GPU software stack
            // â€¢ Hides details about moving data between CPU and GPUs
            let ioSurface = CVPixelBufferGetIOSurface(pixelBuffer)?.takeUnretainedValue(), // In our demo, we've already retain all the pixelBuffer by ourselves
            let texture = device.makeTexture(
                descriptor: descriptor,
                iosurface: ioSurface,
                plane: 0
            )
        else {
            return nil
        }
        return texture
    }

    private func renderTexture(
        foregroundTexture: MTLTexture,
        backgroundTexture: MTLTexture,
        with renderEncoder: MTLRenderCommandEncoder,
        vertexes: [Float],
        textureCoords: [Float],
        pipelineState: MTLRenderPipelineState,
        tweenFactor: Float
    ) {
        // Set the current render pipeline state object.
        renderEncoder.setRenderPipelineState(pipelineState)

        // This is the same as create buffer with `setVertexBuffer`, then call setVertexBuffer(_:offset:index:)
        // set up vertexes
        renderEncoder.setVertexBytes(
            vertexes,
            length: vertexes.count * MemoryLayout<Float>.size,
            index: 0
        )

        // set up textures
        [foregroundTexture, backgroundTexture]
            .enumerated()
            .forEach { offset, texture in
                // for foregroundTexCoords [[ buffer(1) ]] & backgroundTexCoords [[ buffer(2) ]]
                renderEncoder.setVertexBytes(
                    textureCoords,
                    length: textureCoords.count * MemoryLayout<Float>.size,
                    index: 1 + offset
                )

                // for texture2d<half> foregroundTexture [[texture(0)]] & backgroundTexture [[texture(1)]]
                renderEncoder.setFragmentBytes(
                    [tweenFactor, tweenFactor],
                    length: MemoryLayout<Float>.size * 2,
                    index: 2
                )
                renderEncoder.setFragmentTexture(texture, index: offset)
            }

        // Tell the render context we want to draw our primitives (triangle strip).
        renderEncoder.drawPrimitives(
            type: .triangleStrip,
            vertexStart: 0,
            // The vertexes are with the four-dimensional homogenous vector
            vertexCount: vertexes.count / 4
        )
    }
}
